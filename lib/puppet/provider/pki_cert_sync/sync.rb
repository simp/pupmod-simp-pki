Puppet::Type.type(:pki_cert_sync).provide(:redhat) do
  desc <<-EOM
    Synchronizes certificates across the local system.
  EOM

  def initialize(args)
    super

    # Number of times source_insync? has been called for this instance
    # of the provider.  Will be called a second time after the sync
    # operation, if the target dir was not initially in sync.
    @num_insync_calls = 0

    # Hash of Tempfile objects for cacert files
    # Key is name of cacert file in the target_dir
    # Value is Tempfile object
    @ref_tempfiles = {}
  end

  # Sets internal and external state information derived from the contents
  # of the source directory (for efficiency) and returns a subset of that
  # information.
  #
  # The state information is used in source_insync?() and source=() calls.
  # - Internal state is stored in @to_link and @directories
  #   - @to_link is the Hash returned by this method (see below)
  #   - @directories is a list of subdirectories found in the source directory
  # - External state is stored in temporary cacerts.pem and cacerts_no_headers.pem
  #   files
  #   - These are reference files for the aggregate files generated by this
  #     provider's source=() method.
  #   - Each file contains the aggregate of CA certificates found in the
  #     source directory
  #   - cacerts.pem is the aggregate of the raw PEM file content
  #   - cacerts_no_headers.pem is a copy of cacerts.pem for which any X.509
  #     certificate headers have been removed.
  #
  # Returned object is a hash of PEM file info
  # - Each key is a relative file path to a valid PEM file found in the
  #   source directory, or one of the aggregate certificate PEM files
  #   generated by this provider's source=() method.
  # - The value of each key is the name of the top-level link for that
  #   PEM file.
  # - If the PEM file matches the link name, no link is required.
  #
  def source
    src_dir = resource[:source]
    File.directory?(src_dir) or raise Puppet::Error, "'#{src_dir}' is not a valid directory."

    @to_link = {}
    @directories = []

    Dir.chdir(src_dir) do
      # Get all the files, but not the symlinks or cacerts files
      to_parse = Dir.glob('**/*').sort
      to_parse.delete_if { |x| File.symlink?(x) }
      to_parse.delete_if { |x| x =~ cacerts_file_regex }

      # Get all of the directories for later use.
      @directories = to_parse.select { |x| File.directory?(x) }
      # Remove directories from to_parse, they don't belong in to_link!
      to_parse.delete_if { |x| File.directory?(x) }

      # Generate {PEM file, hash link} pairs and the reference cacerts files.
      # Each pair will be {PEM file, PEM file}, instead, when PEM hash link
      # generation is disabled.
      @to_link = generate_pem_info(to_parse, @resource.generate_pem_hash_links?)
    end

    unless @to_link.empty?
      @to_link[cacerts_file] = cacerts_file
      @to_link[stripped_cacerts_file] = stripped_cacerts_file
    end

    @to_link
  end

  # src_info = Hash returned by provider's source() with the following format:
  #   {
  #     PEM_file  => link,
  #     PEM_file2 => link2,
  #     ...
  #   }
  #
  #   NOTE:
  #   - The PEM file is a relative path.
  #   - If the PEM file matches the link name, no link is required.
  #
  # target_dir = directory in which certs listed in src_info should be found
  #
  # If :purge type parameter is set, the target_dir should only contain
  # the certs listed in src_info
  #
  # If :generate_pem_hash_links is set, the target_dir should contain
  # PEM hash links generated by this provider.
  #
  # TODO  Any exceptions raised here will **not** be logged by the
  #  Puppet code wrapping this method. (Specifically, the code
  #  calling the type's insync?() method.) So, either we need to
  #  ensure that no exceptions are raised, or log the exception
  #  messages ourselves, and then re-raise.
  #
  def source_insync?(src_info, target_dir)
    @num_insync_calls += 1
    File.directory?(target_dir) or Dir.mkdir(target_dir, 0o755)
    src_dir = resource[:source]
    insync = true

    Dir.chdir(target_dir) do
      # If we're purging, and the number of files+(optionally) links is different,
      # then we're not in sync.
      files = Dir.glob('**/*').select { |f| File.file?(f) }
      unless @resource.generate_pem_hash_links?
        files.delete_if { |entry| File.symlink?(entry) }
      end

      num_expected_entries = src_info.to_a.flatten.uniq.count
      if @resource.purge? && (files.count != num_expected_entries)
        Puppet.debug("Different number of files/links in #{src_dir} than in #{target_dir}")
        insync = false
        break
      end

      # If we're purging, and directory trees are different, then we're
      # not in sync.
      if @resource.purge?
        dirs = Dir.glob('**/*').select { |d| File.directory?(d) }
        unless dirs.uniq.sort == @directories.uniq.sort
          Puppet.debug("#{src_dir} directory tree differs from #{target_dir}")
          insync = false
          break
        end
      end

      # If the target dir does not have a source file name or its link,
      # then we're not in sync.
      src_info.each do |file, link|
        unless files.include?(file)
          Puppet.debug("Not all files in #{src_dir} are found in #{target_dir}:  Missing #{file}")
          insync = false
          break
        end

        next unless @resource.generate_pem_hash_links? && !files.include?(link)
        Puppet.debug("Not all links in #{src_dir} are found in #{target_dir}:  Missing #{link}")
        insync = false
        break
      end

      if insync
        # All expected files/links exist, but we need to verify each
        # {file,link} pair.
        insync = compare_file_pairs(src_dir, src_info, @resource.generate_pem_hash_links?)
      end

      if insync || (@num_insync_calls == 2)
        # Done with the transient reference files, so remove them.
        ref_file_obj(cacerts_file).unlink
        ref_file_obj(stripped_cacerts_file).unlink
        @ref_tempfiles.clear
      end
    end

    insync
  end

  # Synchronizes the target directory (resource[:name]) with the source
  # directory (resource[:source]) based on internal and external state
  # (generated by the source() method) and the purge parameter.
  #
  # In addition to sychronizing the PEM files found in the source
  # directory, creates a top level hash-named link for each PEM file
  # and aggregate CA certs files.
  #
  # should = Unused
  def source=(_should)
    target_dir = resource[:name]
    Dir.chdir(target_dir) do
      # Purge ALL THE THINGS
      if @resource.purge?
        existing_entries = Dir.glob('**/*')
        unless @resource.generate_pem_hash_links?
          # If we are not managing links, we should leave links alone.
          existing_entries.delete_if { |entry| File.symlink?(entry) }
        end

        # Make sure not to delete directories or certs and their symlinks that we
        # might currently be managing.
        (existing_entries - [@to_link.to_a].uniq.flatten - @directories.flatten).each do |to_purge|
          next if [@to_link.to_a].flatten.any? { |s| s.include?(to_purge) }
          Puppet.notice("Purging '#{target_dir}/#{to_purge}'")
          # Use 'force' option in case a file's directory was purged first
          FileUtils.rm_rf(to_purge)
        end
      end

      # This is simply a canary file to get File['/etc/pki/cacerts'] to trigger
      # a change for all those lovely legacy files out there. Should be
      # deprecated at some point since it's basically noise.
      # FIXME:  Is this still needed?
      FileUtils.touch('.sync_updated')
      FileUtils.chmod(0o644, '.sync_updated')
      # End garbage hacky code

      # Take care of directories first; make them if they don't already exist.
      @directories.each do |dir|
        FileUtils.mkdir_p(dir)
      end

      # Now copy over all items and link them, as appropriate.
      @to_link.each do |src, link|
        if src&.match?(cacerts_file_regex)
          sync_cacerts_file(src)
        else
          sync_cert_file(resource[:source], src, link)
        end
      end

      if @to_link.empty?
        # No managed certs. We need to make sure the aggregate PEM files
        # we create from those certs are removed, even when purging wasn't
        # enabled.
        Puppet.debug("Removing aggregate PEM files in #{target_dir}: No valid managed certificates")
        FileUtils.rm_f(cacerts_file)
        FileUtils.rm_f(stripped_cacerts_file)
      end
    end
  end

  # Getters for what should be constants in a normal Ruby class.
  # Since the class name for this provider is not under our control
  # (i.e., generated by underlying Puppet code), simple getters
  # are easier to maintain.
  def cacerts_file
    'cacerts.pem'
  end

  def stripped_cacerts_file
    'cacerts_no_headers.pem'
  end

  def cacerts_file_regex
    %r{^cacerts(_no_headers)?.pem$}
  end

  # Returns a file object of the reference file for the
  # specified cacerts file
  def ref_file_obj(cacerts_filename)
    unless @ref_tempfiles.key?(cacerts_filename)
      require 'tempfile'
      tempfile = Tempfile.new(File.basename(cacerts_filename))
      @ref_tempfiles[cacerts_filename] = tempfile
    end

    @ref_tempfiles[cacerts_filename]
  end

  # Returns a file path of the reference file for the
  # specified cacerts file
  def ref_file(cacerts_filename)
    unless @ref_tempfiles.key?(cacerts_filename)
      require 'tempfile'
      tempfile = Tempfile.new(File.basename(cacerts_filename))
      @ref_tempfiles[cacerts_filename] = tempfile
    end

    @ref_tempfiles[cacerts_filename].path
  end

  # Helper Methods

  # Compares the content of each file listed in src_info with a reference file,
  # and, optionally ensures the link in src_info is correct.
  #
  # src_dir       = Fully qualified path to the root directory of the reference
  #                 files for individual certificate files.
  # src_info      = Hash returned by provider's source() with the following
  #                 format:
  #                      {
  #                        PEM_file  => link,
  #                        PEM_file2 => link2,
  #                        ...
  #                      }
  #
  # verify_link = Whether to verify each link is correct
  #
  #   NOTE:
  #   - The PEM file is a relative path.
  #   - If the PEM file matches the link name, no link is required.
  #
  def compare_file_pairs(src_dir, src_info, verify_link)
    insync = true
    target_dir = Dir.pwd
    src_info.each do |file, link|
      if file&.match?(cacerts_file_regex)
        # Need to compare with the reference file we created in this
        # directory in the source() method
        if files_different?(ref_file(file), file)
          Puppet.debug("#{target_dir}/#{file} is not current")
          insync = false
          break
        end
      else
        if files_different?("#{src_dir}/#{file}", file)
          Puppet.debug("File contents differ between #{src_dir} and #{target_dir}: #{file} content is incorrect")
          insync = false
          break
        end
        if verify_link
          if (file != link) && (!File.symlink?(link) || (File.readlink(link) != file))
            Puppet.debug("File links in #{target_dir} are not current: #{link} is not a link to #{file}")
            insync = false
            break
          end
        end
      end
    end
    insync
  end

  # Returns a hash of PEM files and their corresponding links for each
  # valid PEM file listed in to_parse. Also generates reference cacerts
  # files (one with and one without x509 certificate headers).
  #
  # - Skips any file that does not contain a x509 certificate
  # - **Only** processes the first x509 certificate in a file
  #
  # to_parse = list of files to be processed; path is relative to
  #            the current working directory
  #
  # generate_hash_links = whether to generate PEM hash links;
  #              When false, the link is set to the original PEM file name.
  #              This signifies to subsequent processing that the link is
  #              not to be generated.
  def generate_pem_info(to_parse, generate_hash_links)
    ref_cacerts = nil
    ref_stripped_cacerts = nil
    ref_cacerts = ref_file_obj(cacerts_file)
    ref_stripped_cacerts = ref_file_obj(stripped_cacerts_file)

    hash_targets = {}
    to_link = {}
    to_parse.sort.each do |file|
      begin
        raw_cert = File.read(file)
        # This will only read in the first cert in a file, so we are
        # *assuming* there will only be one in the file
        cert = OpenSSL::X509::Certificate.new(raw_cert)
      rescue OpenSSL::X509::CertificateError
        # We had a problem, skip this file.
        Puppet.warning("File '#{file}' does not look like an X.509 certificate, skipping")
        next
      end

      ref_cacerts.write(raw_cert)
      ref_stripped_cacerts.write(strip_x509_headers(raw_cert))

      if generate_hash_links
        cert_hash = '%08x' % cert.subject.hash

        # Gather all files that map to the same certificate hash
        # into an array. The index of an entry is used to form
        # the unique numeric ID portion of the hash link name.
        hash_targets[cert_hash] ||= []

        file_prefix, file_suffix = file.split('.')
        if file_prefix == cert_hash
          hash_targets[cert_hash].insert(file_suffix.to_i, file)
        else
          # Insert into first available index
          i = 0
          i += 1 until hash_targets[cert_hash][i].nil?
          hash_targets[cert_hash][i] = file
        end
      else
        # no link is required
        to_link[file] = file
      end
    end

    # Add entries for each PEM file for which a hash link should
    # be generated.
    hash_targets.each_key do |cert_hash|
      i = 0
      hash_targets[cert_hash].each do |file|
        next if file&.match?(cacerts_file_regex)
        # If a PEM file name is a hash link filename, it is inserted
        # at a particular location in the array. This can result gaps
        # (nil values).
        to_link[file] = "#{cert_hash}.#{i}" unless file.nil?
        i += 1
      end
    end
    to_link
  ensure
    ref_cacerts&.close
    ref_stripped_cacerts&.close
  end

  # Compares the contents of two files
  # Returns true if either file is missing or they differ
  # Returns false if the files are the same
  def files_different?(src, dest)
    # If either file is missing, it's different
    return true unless File.exist?(src) && File.exist?(dest)

    # This logic is nearly identical to that in FileUtils.compare_file(),
    # except it hardcodes the blocksize to a small value
    return true if File.stat(src).size != File.stat(dest).size

    # If we've gotten here, brute force by 512B at a time. Stop when a chunk differs.
    s_file = File.open(src, 'r')
    d_file = File.open(dest, 'r')

    retval = false
    until s_file.eof?
      if s_file.read(512) != d_file.read(512)
        retval = true
        break
      end
    end

    s_file.close
    d_file.close
    retval
  end

  # Strips any X.509 headers from a string containing 0 or more,
  # valid, PEM-formatted X.509 certificates
  #
  # **No checks for malformed certificates are done**
  #
  # certs_raw = String containing list of certificates
  #
  # Returns stripped string when 1 or more certificates are found
  # Returns an empty string otherwise
  #
  def strip_x509_headers(certs_raw)
    begin_regex = %r{^#{Regexp.escape('-----BEGIN CERTIFICATE-----')}$}
    end_regex = %r{^#{Regexp.escape('-----END CERTIFICATE-----')}$}

    cert_lines = []
    cert_begin_found = false
    certs_raw.split("\n").each do |line|
      if cert_begin_found
        cert_lines << line
        cert_begin_found = false if line.match(end_regex)
      elsif line.match(begin_regex)
        cert_begin_found = true
        cert_lines << line
      end
    end

    certs = ''
    unless cert_lines.empty?
      certs = cert_lines.join("\n") + "\n"
    end
    certs
  end

  # Synchronize the contents of the generated, aggregate CA certificates
  # file with its reference file
  #
  # file = aggregate CA certificates file to synchronize
  def sync_cacerts_file(file)
    target_dir = Dir.pwd
    ref = ref_file(file)
    if File.exist?(ref)
      if File.exist?(file)
        selinux_context = resource.get_selinux_current_context("#{target_dir}/#{file}")
      end

      FileUtils.cp(ref, file)
      FileUtils.chmod(0o644, file)

      if selinux_context.nil?
        Puppet.debug("Could not get selinux context for '#{target_dir}/#{file}'")
      else
        resource.set_selinux_context("#{target_dir}/#{file}", selinux_context).nil? and
          Puppet.debug("Could not set selinux context on '#{file}'")
      end
    else
      Puppet.warning("Skipping sync of #{target_dir}/#{file}: Source no longer exists")
    end
  end

  # Synchronize the contents of the certificate file with its reference file,
  # and, as appropriate, generate the corresponding link.
  #
  # When file == link, no link is required.
  #
  # src_dir = Fully qualified path to the root directory of the reference file
  # file    = relative path of the certificate file to synchronize
  # link    = relative path of the link to generate
  #
  def sync_cert_file(src_dir, file, link)
    target_dir = Dir.pwd
    if File.exist?("#{src_dir}/#{file}")
      selinux_context = if File.exist?(file)
                          resource.get_selinux_current_context("#{target_dir}/#{file}")
                        else
                          resource.get_selinux_current_context("#{src_dir}/#{file}")
                        end

      selinux_context.nil? and
        Puppet.debug("Could not get selinux context for '#{src_dir}/#{file}'")

      FileUtils.cp("#{src_dir}/#{file}", file, preserve: true)
      resource.set_selinux_context("#{target_dir}/#{file}", selinux_context).nil? and
        Puppet.debug("Could not set selinux context on '#{file}'")

      # Only link if the names are different.
      if file != link
        FileUtils.ln_sf(file, link)
        # Have to set the SELinux context here too since symlinks can have
        # different contexts than files.
        resource.set_selinux_context("#{target_dir}/#{link}", selinux_context).nil? and
          Puppet.debug("Could not set selinux context on link '#{link}'")
      end
    else
      Puppet.warning("Skipping sync of #{target_dir}/#{file}: Source no longer exists")
    end
  end
end
